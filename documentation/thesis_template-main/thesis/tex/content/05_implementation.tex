\chapter{Implementation}

\section{Technologiestack und Entwicklungsumgebung}
Aufgrund der bereits vorhandenen Labore wurde auch für dieses Labor Jupyter Notebook gewählt, eine Web-basierte Platform, in der Python programmiert werden kann. Weitere Gründe für Jupyter Notebook sind die einfache Bedienbarkeit, in welcher jeder dieses verwenden kann und keine lokale Konfiguration stattfinden muss, die didaktisch gute Kombination von Python-Code, Text und \LaTeX-Formeln sowie das Darstellen von Plots.

Als Programmiersprache wurde Python gewählt, da diese sich hervorragend für Berechnungen und Simulationen eignet. Die Kombination mit den verwendeten Bibliotheken NumPy, Matplotlib und IPython.display eignet sich sehr gut für numerische Berechnungen und die Visualisierung der Ergebnisse.  


\section{Aufbau des Labors}
Der Aufbau des Labors orientiert sich an dem Aufbau von dem Labor des Roboter-Arms an. Das bedeutet zunächst folgt eine Einleitung in das Thema mit einem kleinen Video, gefolgt von einer mathematischen Einleitung in das Thema, ein paar Aufgaben, welche dann zum weiteren Verständnis mithilfe von Python und den genannten Bibliotheken visualisiert werden als Simulationen. Aufgrund dieser Simulationen soll tieferes Verständnis für die Wärmeleitungsgleichung in Festkörpern vermittelt werden. 


\section{Funktionsgraphen und Simulationen}
Die bereits angekündigten Schaubilder und Simulationen können nachfolgend als Bilder betrachtet werden. Für einen leichteren Einstieg geht es bei der ersten Implementierungs- und Visualisierungs-Aufgabe um eine simple Sinusfunktion. 

Die Lösung kann wie folgt aussehen:
\begin{lstlisting}[caption={Python Code für einfachen Sinus}]
# Simple One sine (k=1): u(x,t) = sin(x) * exp(-a^2*k^2*t)
def u_sin_xt(x, t, a2, k2):
    # Single sine with homogeneous Dirichlet Boundary conditions
    # Initial graph meets exponential decay time factor
    return np.sin(x) * np.exp(-a2 * k2* t)  
\end{lstlisting}


Dadurch entsteht dann folgendes Schaubild:

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/SingleSineDiagram.png}
  \caption{Sinusgraph}
  \label{fig:heat-simulation}
\end{figure}
Deutlich zu erkennen ist, mit zunehmender Zeit nähert sich der Graph der $x$-Achse an. Ursache ist der exponentielle Faktor $\exp(-a^2k^2t)$, der den zeitlichen Anteil der Lösung beschreibt und zu einem Abklingen der Amplitude führt.


Nach dem erfolgreichen Abschluss der einfachen Sinusfunktion folgt die Implementation/Definition von 2 Funktionen mit den Aufgaben, der Berechnung des Fourier-Koeffizienten $b_k$ und der Berechnung der Temperatur $u(x,t)$ basierend auf der Fourier-Reihe. Auf Basis dieser 2 Funktionen lassen sich dann die beiden nachfolgenden Schaubilder erzeugen. Diese zeigen zum einen, wie sich der Graph der Anfangsbedingung $u(x,0)=1$ nähert, umso mehr Sinuswellen hinzugefügt werden. Zum anderen zeigen die Graphen, wie sich die Fourier-Reihe nach einer kurzen Zeit dem Verlauf der einfachen Sinusfunktion annähert.

Eine mögliche Lösung bietet dieser Code-Abschnitt:
\begin{lstlisting}[caption={Python Code für Fourier Graphen}]
# Calculates the fourier sinus coefficient b_k for f(x)=1
def coeff(N):
    k = np.arange(1, N + 1, dtype=float)    # Create an array k with numbers from 1 to N (k=1 big waves, k=100 small waves)
    b_k = 2.0 * (1.0 - np.cos(k * np.pi)) / (np.pi * k)    # Calculate fourier coefficient b_k with given formula
    return k, b_k

# Calculates the temperature u(x,t) at time t and location x based on the fourier series 
def u_xt(x, t, a2, N):
    x_arr = np.asarray(x, dtype=float)  # Convert input x to array
    x_flat = x_arr.reshape(1, -1)   # Make an array with 1 row and as many columns as x_arr has elements
    k, b_k = coeff(N)  # Get fourier coefficients
    k = k[:, None]  # Change array k to one column and as many rows as k has elements
    terms = b_k[:, None] * np.sin(k * x_flat) * np.exp(-a2 * (k ** 2) * t)  # Calculate the terms of the Fourier series for each k and x at the time t
    u_flat = terms.sum(axis=0)  # Add all the fourier terms together for each x to get the temperature u(x,t) at time t
    return u_flat.reshape(x_arr.shape)  # Reshape the flat array back to the original shape of x_arr (reshape important, when function is called with plt.plot)

\end{lstlisting}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/InitialConditionApproximation.png}
  \caption{Annäherung an die Anfangsbedingung}
  \label{fig:heat-simulation3}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/TruncatedFourierSineSolution.png}
  \caption{Zeitlicher Verlauf der Fourier Sinus Reihe}
  \label{fig:heat-simulation2}
\end{figure}

\FloatBarrier

\subsection{Gibbsches Phänomen in der Simulation}
Das Gibbsche Phänomen ist hier bei der Fourier-Sinusreihe, bei dem Graphen der Annäherung an die Anfangsbedingung zu sehen. Es handelt sich hierbei um die beiden Stellen nahe $x=0$ und $x=\pi$. Deutlich wird das, umso mehr Sinuswellen hinzugefügt werden sich das Gibbsche Phänomen verkleinert, allerdings nicht aufhört zu existieren.

\subsection{Überschwingungen glätten}
Da es sich bei der Anfangsbedingung $u(x,0)=1$ um eine waagerechte Funktion handelt, lassen sich die Überschwingungen recht deutlich erkennen. Bei dem Graphen der Annäherung an die Anfangsbedingung sind die einzelnen Sinuswellen gut sichtbar, also die Überschwingungen. Denn das Ziel ist es ja, mit Fourier die Anfangsbedingung so gut wie möglich zu erfüllen. Diesem Ziel kommt man immer näher, umso mehr Sinuswellen hinzugefügt werden, also wenn man N entsprechend hoch wählt, glättet man die Überschwingungen. Dies kann man auch bei der Simulation einfach anpassen. Dadurch verlängert sich aber auch die benötigte Zeit zur Berechnung des Funktionsgraphen.
