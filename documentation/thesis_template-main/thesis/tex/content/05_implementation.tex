\chapter{Implementation}

\section{Technologiestack und Entwicklungsumgebung}
Aufgrund der bereits vorhandenen Labore wurde auch für dieses Labor auf Jupyter Notebook gewählt, eine Webanwendung, in der Python programmiert werden kann. Weitere Gründe für Jupyter Notebook sind die einfache Bedinbarkeit, in welcher jeder dieses verwenden kann und keine lokale Konfiguration stattfinden muss, die didaktisch gute Kombination von Python-Code, Text und LaTeX-Formeln sowie das Darstellen von Plots.

Als Programmiersprache wurde Python gewählt, da diese sich hervorragend für Berechnungen und Simulationen eignet. Die Kombination mit den verwendeten Bibliotheken NumPy, Matplotlib und IPython.display eignet sich sehr gut für numerische Berechnungen und die Visualisierung der Ergebnisse.  


\section{Aufbau des Labors}
Der Aufbau des Labors lehnt sich an dem Aufbau von dem Labor des Roboter-Arms an. Das bedeutet zunächst folgt eine Einleitung in das Thema mit einem kleinen Video, gefolgt von einer mathematischen Einleitung in das Thema, ein paar Aufgaben, welche dann zum weiteren Verständnis mithilfe von Python und den genannten Bibliotheken visualisiert werden als Simulationen. Aufgrund dieser Simulationen soll tieferes Verständnis für die Wärmeleitungsgleichung in Festkörpern erzeugt werden. 

Der Aufbau ist wie folgt:
\begin{enumerate}
\item Imports: Sollen gleich bleiben, wie bei den anderen Laboren.

\item Modelling: Als Einleitung zum Thema wird ein Video eingefügt. Dieses Video beschreibt das Verhalten eines eindimensionalen Stabelements, wenn es an einer Seite durch eine Wärmequelle erhitzt wird. 

\item Derivation of the heat equation: Darauf folgt die Herleitung der Wärmeleitungsgleichung aus der Energiebilanz in einem infinitesimalen Volumenelement. 

\item Numerical treatment: In diesem Kapitel muss der Student seine erste Aufgabe lösen. Diese beinhaltet das Berechnen des Temperaturleitkoeffizienten. Die notwendigen Informationen sind entweder direkt oder durch Wikipedia Links bereitgestellt. Darauf folgend wird dann die Wärmeleitungsgleichung gelöst, während Anfangs- und Randbedingungen beachtet werden.

\item Implementation \& Visualization: Nach dem Schaffen der Grundlagen werden dann Simulationen erstellt, welche es möglich machen, das erworbene Wissen praktisch anzuwenden. In diesen Python-Programmen, wird durch Ausfüllen der Lücken einzelne Schaubilder und Simulationen erstellt, welche auch selbst gesteuert werden können und bei denen die Studenten später die Möglichkeit haben, einzelne Parameter anzupassen, um beispielsweise verschiedene Materialien zu simulieren. 
\end{enumerate}

\section{Funktionsgraphen und Simulationen}
Die bereits angekündigten Schaubilder und Simulationen können nachfolgend als Bilder betrachtet werden. Für einen leichteren Einstieg geht es bei der ersten Implementierungs- und Visualisierungs-Aufgabe um eine simple Sinusfunktion. 

Die Lösung kann wie folgt aussehen:
\begin{lstlisting}[caption={Python Code für einfachen Sinus}]
# Simple One sine mode (k=1): u(x,t) = sin(x) * exp(-a^2 t)
def u_sin_xt(x, t, a2):
    # Single sine mode with homogeneous Dirichlet Boundary conditions
    # Initial graph meets exponential decay time factor
    return np.sin(x) * np.exp(-a2 * t)  
\end{lstlisting}


Dadurch entsteht dann folgendes Schaubild:

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/SingleSineModeDiagram.png}
  \caption{Sinus Graph}
  \label{fig:heat-simulation}
\end{figure}
Hier ist die Entwicklung des Graphen klar zu sehen und wie sich dieser nach verstrichener Zeit der x-Achse nähert, was auf die e-Funktion zurückzuführen ist, also den zeitlichen Teil der Gleichung.


Nach dem erfolgreichen Abschluss der einfachen Sinusfunktion folgt die Definition von 3 Funktionen mit den Aufgaben, der Berechnung des Fourier-Koeffizienten $C_k$, der Berechnung der Temperatur $u(x,t)$ basierend auf der Fourier-Reihe und dem Speichern der Temperaturen in einem 2D-Array. Auf Basis dieser 3 Funktionen lassen sich dann die beiden nachfolgenden Schaubilder erzeugen. Diese zeigen zum einen, wie sich der Graph der Anfangsbedingung $u(x,t)=1$ nähert, umso mehr Sinuswellen hinzugefügt werden. Zum anderen zeigen die Graphen, wie sich die Fourier-Reihe nach einer kurzen Zeit dem Verlauf der einfachen Sinusfunktion annähert.

Eine Mögliche Lösung bietet dieser Code-Abschnitt:
\begin{lstlisting}[caption={Python Code für Fourier Graphen}]
# Calculates the fourier sinus coefficient c_k for f(x)=1
def coeffs(N):
    k = np.arange(1, N + 1, dtype=float)    # Create an array k with numbers from 1 to N (k=1 big waves, k=100 small waves)
    c_k = 2.0 * (1.0 - np.cos(k * np.pi)) / (np.pi * k)    # Calculate fourier coefficient c_k with given formula
    return k, c_k

# Calculates the temperature u(x,t) at time t and location x based on the fourier series 
def u_xt(x, t, a2, N):
    x_arr = np.asarray(x, dtype=float)  # Convert input x to array
    x_flat = x_arr.reshape(1, -1)   # Make an array with 1 row and as many columns as x_arr has elements
    k, c_k = coeffs(N)  # Get fourier coefficients
    k = k[:, None]  # Change array k to one column and as many rows as k has elements
    terms = c_k[:, None] * np.sin(k * x_flat) * np.exp(-a2 * (k ** 2) * t)  # Calculate the terms of the Fourier series for each k and x at the time t
    u_flat = terms.sum(axis=0)  # Add all the fourier terms together for each x to get the temperature u(x,t) at time t
    return u_flat.reshape(x_arr.shape)  # Reshape the flat array back to the original shape of x_arr (reshape important, when function is called with plt.plot)

\end{lstlisting}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/InitialConditionApproximation.png}
  \caption{Annäherung an die Anfangsbedingung}
  \label{fig:heat-simulation3}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/TruncatedFourierSineSolution.png}
  \caption{Zeitlicher Verlauf der Fourier Sinus Reihe}
  \label{fig:heat-simulation2}
\end{figure}

\FloatBarrier

\subsection{Gibbsches Phänomen in der Simulation}
Das Gibbsche Phänomen ist hier bei der Fourier-Sinusreihe zu sehen. Es handelt sich hierbei um die beiden hellsten Stellen nahe $x=0$ und $x=\pi$. Ebenfalls zu erkennen ist es bei dem Graphen der Annäherung an die Anfangsbedingung. Deutlich wird das, umso mehr Sinuswellen hinzugefügt werden sich das Gibbsche Phänomen verkleinert, allerdings nicht aufhört, zu existieren.

\subsection{Überschwingungen glätten}
Da es sich bei der Anfangsbedingung $u(x,t)=1$ um eine waagerechte Funktion handelt, lassen sich die Überschwingungen recht deutlich erkennen. Gerade das Wärmebild zeigt zu Zeitpunkt $t=0$ ms die einzelnen Sinuswellen, also die Überschwingungen. Denn das Ziel ist es ja, mit Fourier die Anfangsbedingung so gut wie möglich zu erfüllen. Diesem Ziel kommt man immer näher, umso mehr Sinuswellen hinzugefügt werden, also wenn man N entsprechend hoch wählt, glättet man die Überschwingungen. Dies kann man auch bei der Simulation einfach anpassen. Dadurch verlängert sich aber auch die benötigte Zeit zur Berechnung.
