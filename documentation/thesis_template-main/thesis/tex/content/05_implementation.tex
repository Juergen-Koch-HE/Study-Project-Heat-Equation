\chapter{Implementation}

\section{Technologiestack und Entwicklungsumgebung}
Aufgrund gegebenen Laboren, wurde auf für dieses Labor auf Jupyter Notebook gesetzt als Webanwendung in der Python programmiert werden kann. Weitere Gründe für Jupyter Notebook sind die Einfachheit, in welcher jeder dieses Verwenden kann und keine lokale konfiguration stattfinden muss, die didaktisch gute Kombination von Python-Code, Text und LaTeX-Formeln, sowie das darstellen von Plots.

Als Programmiersprache wurde Python gewählt, da diese sich hervorragend für Berechnungen und Simulationen eignet. Die Kombination mit den verwendeten Bibliotheken NumPy, Matplotlib und IPython.display eignet sich sehr gut für numerische Berechnungen und Visualisierung der Ergebnisse.  


\section{Aufbau des Labors}
Der Aufbau des Labors lehnt sich an dem Aufbau von dem Labor des Roboter-Arms. Das bedeutet zunächst folgt eine Einleitung in das Thema mit einem kleinen Video, gefolgt von einer mathematischen Einleitung in das Thema, ein paar Aufgaben, welche dann zum weiteren Verständnis mithilfe von Python und den genannten Bibliotheken visualisiert werden als Simulationen. Aufgrund dieser Simulationen soll tieferes Verständnis für die Wärmeleitungsgleichung in Festkörpern erzeugt werden. 

Der Aufbau ist wie folgt:
\begin{enumerate}
\item Imports: Sollen gleich bleiben, wie bei den anderen Laboren.

\item Modelling: Als Einleitung zum Thema, wird ein Video eingefügt dieses Video beschreibt das Verhalten eines eindimensionalen Stabelements, wenn es an einer Seite durch eine Wärmequelle erhitzt wird. 

\item Derivation of the heat equation: Darauf folgt die Herleitung der Wärmeleitungsgleichung aus der Energiebilanz in einem infinitesimalen Volumenelement. 

\item Numerical treatment: In diesem Kapitel muss der Student seine erste Aufgabe lösen, diese beinhaltet das Berechnen des Temperaturleitkoeffizienten. Die notwendigen Informationen sind entweder direkt oder durch Wikipedia Links bereitgestellt. Darauf folgend wird dann die Wärmeleitungsgleichung gelöst während Anfangs- und Randbedingungen beachtet werden.

\item Implementation \& Visualization: Nach dem schaffen der Grundlagen werden dann Simulationen erstellt welche es möglich machen das erworbene Wissen praktisch anzuwenden. In diesen Python Programmen, wird durch ausfüllen der Lücken einzelne Schaubilder und Simulationen erstellt, welche auch selbst gesteuert werden können und die Studenten später die Möglichkeit haben einzelne Parameter anzupassen um beispielsweise verschiedene Materialien zu simulieren. 
\end{enumerate}

\section{Funktionsgraphen und Simulationen}
Die bereits angekündigten Schaubilder und Simulationen können nachfolgend als Bilder betrachtet werden. Für einen leichteren Einstieg geht es bei der ersten Implementierungs- und Visualisierungs-Aufgabe um eine simple Sinus Funktion. 

Die Lösung kann wie folgt aussehen:
\begin{lstlisting}[caption={Python Code für einfachen Sinus}]
# Simple One sine mode (k=1): u(x,t) = sin(x) * exp(-a^2 t)
def u_sin_xt(x, t, a2):
    # Single sine mode with homogeneous Dirichlet Boundary conditions
    # Initial graph meets exponential decay time factor
    return np.sin(x) * np.exp(-a2 * t)  
\end{lstlisting}


Dadurch entsteht dann folgendes Schaubild:

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/SingleSineModeDiagram.png}
  \caption{Sinus Graph}
  \label{fig:heat-simulation}
\end{figure}
Hier ist die Entwicklung des Graphen klar zu sehen und wie sich dieser nach verstrichener Zeit der x-Achse näher, was auf die e-Funktion zurückzuführen ist, also den zeitlichen Teil der Gleichung.


In der nächsten Aufgabe geht es dann darum die erstellte Funktion aus der vorangegangenen Aufgabe zu nutzen. Über eine Schleife soll ein 2-Dimensionales Array gefüllt werden, mit den Werten dieser Funktion. Eine Mögliche Lösung kann so aussehen:
\begin{lstlisting}[caption={Python Code für einfachen Sinus - Heatmap}]
# 1D "thermal camera" animation for the single sine mode
# Create list of time steps for animation with dt_ms as time steps between the start and end which is anim_t_end_ms + dt_ms
t_vals = np.arange(0, anim_t_end_ms + dt_ms, dt_ms) / 1000.0    
U_sin = np.empty((len(t_vals), len(x_vals)))    # Allocate empty 2D array with the length of t_vals and x_vals
for i, t in enumerate(t_vals):  # Loops over all the time steps, with index i and time step from t_vals
    U_sin[i, :] = u_sin_xt(x_vals, t, a2)   # Fill the row i, all columns with the temperature values at time t in the table U_sin

U_min, U_max = float(U_sin.min()), float(U_sin.max())   # Get global Maximum and Minimum from U_sin
\end{lstlisting}
Die dazugehörige Simulation:
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/SingleSineModeHeatmap.png}
  \caption{Sinus Graph Wärmebild}
  \label{fig:heat-simulation1}
\end{figure}


Nach dem erfolgreichen Abschluss der einfachen Sinus Funktion folgt die Definition von 3 Funktionen mit den Aufgaben, der Berechnungen des Fourier Koeffizienten $C_k$, der Berechnung der Temperatur $u(x,t)$ basierend auf der Fourier-Reihe und dem Speichern der Temperaturen in einem 2D Array. Auf Basis dieser 3 Funktionen lassen sich dann die beiden nachfolgenden Schaubilder erzeugen. Diese zeigen zum einen, wie sich der Graph der Anfangsbedingung $u(x,t)=1$ nähert, umso mehr Sinus-Wellen hinzugefügt werden. Zum anderen zeigen die Graphen, wie sich die Fourier-Reihe nach einer kurzen Zeit dem Verlauf der einfachen Sinus Funktion annähert.

Eine Mögliche Lösung bietet dieser Code-Abschnitt:
\begin{lstlisting}[caption={Python Code für Fourier Graphen}]
# Calculates the fourier sinus coefficient c_k for f(x)=1
def coeffs(N):
    k = np.arange(1, N + 1, dtype=float)    # Create an array k with numbers from 1 to N (k=1 big waves, k=100 small waves)
    c_k = 2.0 * (1.0 - np.cos(k * np.pi)) / (np.pi * k)    # Calculate fourier coefficient c_k with given formula
    return k, c_k

# Calculates the temperature u(x,t) at time t and location x based on the fourier series 
def u_xt(x, t, a2, N):
    x_arr = np.asarray(x, dtype=float)  # Convert input x to array
    x_flat = x_arr.reshape(1, -1)   # Make an array with 1 row and as many columns as x_arr has elements
    k, c_k = coeffs(N)  # Get fourier coefficients
    k = k[:, None]  # Change array k to one column and as many rows as k has elements
    terms = c_k[:, None] * np.sin(k * x_flat) * np.exp(-a2 * (k ** 2) * t)  # Calculate the terms of the Fourier series for each k and x at the time t
    u_flat = terms.sum(axis=0)  # Add all the fourier terms together for each x to get the temperature u(x,t) at time t
    return u_flat.reshape(x_arr.shape)  # Reshape the flat array back to the original shape of x_arr (reshape important, when function is called with plt.plot)

# Calculates u(x,t) for all positions x and time steps t and stores the results in a 2D array
def u_grid(x_grid, t_grid, a2, N):
    U = np.empty((len(t_grid), len(x_grid)), dtype=float)   # Allocate empty 2D array for the results based on the length of t_grid and x_grid
    # Loop over all time steps with index i and time t from t_grid, and fill the row i and all columns with the temperature values 
    for i, t in enumerate(t_grid):
        U[i, :] = u_xt(x_grid, t, a2, N)
    return U
\end{lstlisting}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/InitialConditionApproximation.png}
  \caption{Annäherung an die Anfangsbedingung}
  \label{fig:heat-simulation3}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/TruncatedFourierSineSolution.png}
  \caption{Zeitlicher Verlauf der Fourier Sinus Reihe}
  \label{fig:heat-simulation2}
\end{figure}



Zum Abschluss wird noch die Fourier Sinus Reihe als Simulation erstellt. Wie bereits der einfache Sinus wird die Reihe als Wärmebild dargestellt. Für diese Aufgabe wird eine zuvor erstellte Funktion verwendet um, wie bei der Sinus Funktion ein 2D Array mit dem Temperaturwerten zu füllen. Eine Möglichkeit das zu tun ist folgende:

\begin{lstlisting}[caption={Python Code für Fourier Wärmebild}]
# Create list of time steps for animation with dt_ms as time steps between the start and end which is anim_t_end_ms + dt_ms
t_vals = np.arange(0, anim_t_end_ms + dt_ms, dt_ms) / 1000.0
U = u_grid(x_vals, t_vals, a2, N)
U_min, U_max = float(U.min()), float(U.max())   # Get global Maximum and Minimum from U_sin
\end{lstlisting}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/FourierSineModeHeatmapBeginning.png}
  \caption{Fourier Sinus Reihe bei $t=0$ ms}
  \label{fig:heat-simulation4}
\end{figure}


Wie bereits erwähnt ähnelt auch die Fourier Sinus Reihe dem des einfachen Sinus, nach kurzer Zeit ($t=120$ ms), wie nachfolgend zu sehen ist.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{content/figures/FourierSineModeHeatmapLater.png}
  \caption{Fourier Sinus Reihe bei $t=120$ ms}
  \label{fig:heat-simulation5}
\end{figure}

\FloatBarrier

\subsection{Gibbsches Phänomen in der Simulation}
Das Gibbsche Phänomen ist hier bei der Fourier Sinus Reihe zu sehen, es handelst sich hierbei um die beiden hellsten Stellen nahe $x=0$ und $x=\pi$. Ebenfalls zu erkennen ist es bei dem Graphen der Annäherung an die Anfangsbedingung. Deutlich wird das umso mehr Sinus-Wellen hinzugefügt werden, das Gibbsche Phänomen sich verkleinert, allerdings nicht aufhört zu existieren.

\subsection{Überschwingungen Glätten}
Da es sich bei der Anfangsbedingung $u(x,t)=1$ um eine waagerechte Funktion handelt, lassen sich die Überschwingungen recht deutlich erkennen. Gerade das Wärmebild zeigt zu Zeitpunkt $t=0$ ms die einzelnen Sinuswellen, also die Überschwingungen. Denn das Ziel ist es ja mit Fourier die Anfangsbedingung so gut wie möglich zu erfüllen. Diesem Ziel kommt man immer näher, umso mehr Sinus-Wellen hinzugefügt werden, also wenn man N entsprechend hoch wählt glättet man die Überschwingungen. Dies kann man auch bei der Simulation einfach anpassen, dadurch verlängert sich aber auch die benötigte Zeit zur Berechnung.
